.Dd 2023
.Dt 1
.Sh Name
.Nm smlfut
.Nd call Futhark from Standard ML.
.
.Sh Synopsis
.Nm
.SY smlfut
.Op Ar options
.Bk
.Ar MANIFEST.json
.Ek
.
.Sh Description
.Nm
allows SML programs to invoke Futhark programs via Futhark's C API, by
generating appropriate wrapper code, which is then compiled as normal
with an SML compiler.  Given a manifest file in JSON format,
.Nm
produces two output files, containing signature and structure
definitions respectively, in the same directory as the manifest file.
.
.Sh Options
.
.Bl -tag
.
.It Fl -output-directory Ns = Ns Ar NAME
Write output files to this directory.
.
.It Fl -signature-name Ns = Ns Ar NAME
Use this name for the SML signature.  Defaults to the uppercased
basename of the manifest file.
.
.It Fl -structure-name Ns = Ns Ar NAME
Use this name for the SML structure.  Defaults to the basename of the
manifest file.
.El
.
.Sh Usage
.Pp
First compile a Futhark program
.I foo.fut
with
.Xr futhark 1
using one of the C backends, then pass the generated JSON manifest
file
.I foo.json
to
.Nm .
.
This will produce two files
.I foo.sig
and
.IR foo.sml ,
containing a signatures and structure definitions respectively.  The
name of the structure will be taken from the file basename (in this
case
.IR foo ),
and the signature name will be the structure name in
uppercase
.RI ( FOO ).
.
The generated files must then be compiled with a SML compiler.
.
The generated interface directly exposes the C API, so it is low
level.  The only concession is that the C error codes are turned into
SML exceptions.
.Pp
The generated signatures are designed to be human readable and should
be mostly straightforward.  The general principle is that you construct a
.I "context"
by passing a configuration record.  The context maintains Futhark
state and is passed to entry points and various other functions.
Different context objects are not interchangeable, despite having the
same type, and Futhark values obtained via one context may not be
passed to another.
.Pp
Futhark's scalar types are mapped directly to the corresponding SML types, e.g.
.Em f64
to
.Em Real64 .
Arrays and opaque types are mapped to abstract SML types, each
contained in a structure that defines functions for interacting with
them.  Futhark types that are records have functions exposed for
copying between them and SML records.  Note that if you convert a
Futhark record into an SML record, you must still also free the
original Futhark record at some point.
.
.Pp
In contrast to the C API, the functions for copying data to and from
Futhark are synchronous, and do not need explicit synchronisation.
However, entry points are still asynchronous, meaning that errors can
be delayed until a future operation.  Use the 'sync' function if you
want to ensure all errors have been checked.
.
.Sh Generated Interface
.
Each Futhark entry point becomes a function with two parameters: the
context object, and a tuple with one element per parameter of the
original Futhark function.
.
.Sh Linking Futhark with MLton
.
The Futhark compiler produces C code, which must be passed to
.Xr mlton 1
in order to produce an executable.  This can be done simply by passing
the .c file to
.Xr mlton 1
on the command line, along with the .sml and/or .mlb file.  However,
if you want to use a GPU backend, you must also pass the appropriate
linker flags, e.g.
.Pp
.Li mlton foo.mlb foo.c -link-opt '-lcuda -lnvrtc -lcudart'
.Pp
for CUDA.  See the Futhark documentation for the appropriate linker
flags needed for a given backend.
.Sh Bugs
The generated code currently supports only MLton (and perhaps MPL).
.Pp
The generated code directly exposes the manual memory management
required by Futhark's C interface.  If you neglect to free the values
built using constructor functions or entry points, you will leak
memory.  Freeing the context before freeing all associated values will
also leak memory.
.Pp
Be careful not to mix values associated with different contexts.  They
have the same type, so this is an easy mistake to make.
.
.Sh License
.Nm
itself is released under the GPLv3 or later.  The code
.I generated
by
.Nm
may be used for any purpose, without restrictions or requirements,
without any need for attribution.
