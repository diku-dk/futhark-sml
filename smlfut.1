.Dd 2024
.Dt smlfut 1
.Os DIKU
.Sh Name
.Nm smlfut
.Nd call Futhark from Standard ML.
.
.Sh Synopsis
.Nm
.SY smlfut
.Op Ar options
.Bk
.Ar MANIFEST.json
.Ek
.
.Sh Description
.Nm
allows SML programs to invoke Futhark programs via Futhark's C API, by
generating appropriate wrapper code, which is then compiled as normal
with an SML compiler.
.
.Sh Options
.
.Bl -tag
.
.It Fl -mono-arrays
Equivalent to
.Fl -target=mlton-mono .
.
.It Fl -poly-arrays
Equivalent to
.Fl -target=mlton-poly .
.
.It Fl -output-directory Ns = Ns Ar NAME
Write output files to this directory.
.
.It Fl -signature-name Ns = Ns Ar NAME
Use this name for the SML signature.  Defaults to the uppercased
basename of the manifest file.
.
.It Fl -structure-name Ns = Ns Ar NAME
Use this name for the SML structure.  Defaults to the basename of the
manifest file.
.
.It Fl -target Ns = Ns Ar TARGET
Target this SML compiler.  Must be one of
.Ar mlkit ,
.Ar mlton-poly ,
or
.Ar mlton-mono
(the default).
.
.It Fl V Ns , Fl -version
Print version information.
.
.El
.
.Sh Usage
.Pp
First compile a Futhark program
.Li foo.fut
with
.Xr futhark 1
using one of the C backends, then pass the generated JSON manifest
file
.Li foo.json
to
.Nm .
.
This will produce three files:
.Li foo.sig Ns ,
.Li foo.sml Ns ,
and
.Li foo.smlfut.c Ns .
.
The first two files contain definitions of SML signatures and
structures, while the last contains C code.  The name of the structure
will be taken from the file basename (in this case 'foo') and the
signature name will be the structure name in all caps ('FOO').  The
generated SML files can be passed to the SML compiler, and the final
executable must be linked with
.Li foo.smlfut.c Ns
.Ns ,
and of course the C file generated by the Futhark compiler itself.
.Pp
The generated interface directly exposes the C API, so it is low
level.  The only concession is that the C error codes are turned into
SML exceptions.
.Pp
The generated signatures are designed to be human readable and should
be mostly straightforward.  The general principle is that you construct a
.Em "context"
by passing a configuration record.  The context maintains Futhark
state and is passed to entry points and various other functions.
Different context objects are not interchangeable, despite having the
same type, and Futhark values obtained via one context may not be
passed to another.
.Pp
..
.Sh Top level signature
.
The generated structure implements the following signature (here using
the name
.Li FUTHARK ,
but this is taken from the program file name or the
.Fl -signature-name
option).
.Bd -literal -offset indent
signature FUTHARK =
sig
  val backend : string
  val version : string

  type ctx
  exception Error of string
  exception Free of string
  type cfg = { logging:bool,
             , debugging:bool
             , profiling:bool
             , cache:string option
             , tuning: (string * int) list
               (* Possibly more *)
             }

  structure Config : sig
    (* See below *)
  end

  structure Context : sig
    (* See below *)
  end

  (* Array specs... *)

  structure Opaque : sig
    (* Opaque type specs... *)
  end

  structure Entry : sig
    (* Entry points... *)
  end
end
.Ed
.Ss Description
.Bl -tag -width indent
.It Li backend
The Futhark compiler backend used to compile the program.
.It Li version
The Futhark compiler version used to compile the program.
.It Li exception Error
Raised when Futhark execution fails.  The string is the error message
reported by Futhark.
.It Li exception Free
Raised when an attempt is is made to use an object that has been freed.
.It Li type ctx
Contains Futhark runtime state.
.It Li type cfg
Configuration record used to create the context.  Depending on the
backend, this record may have more fields.
.It Li structure Config/Context/Opaque/Entry
See below.
.El
.
.Pp
.
.Sh The Config Structure
.
Facilities for easily constructing or modifying configuration records.
In particular, the structure exposes a
.Em setter
for each field in the configuration record, as SML's built-in
facilities for updating records are rather cumbersome.
.
.Bd -literal -offset indent
structure Config : sig
  val default : cfg
  val logging : bool -> cfg -> cfg
  val debugging : bool -> cfg -> cfg
  val profiling : bool -> cfg -> cfg
  val cache : string option -> cfg -> cfg
  val tuning : (string * int) list -> cfg -> cfg
  (* Possibly more *)
end
.Ed
.
.Sh The Context Structure
.
The context is essentially the Futhark runtime state.
.
.Bd -literal -offset indent
structure Context : sig
  val new : cfg -> ctx
  val free : ctx -> unit
  val sync : ctx -> unit
  val report : ctx -> string
  val pauseProfiling : ctx -> unit
  val unpauseProfiling : ctx -> unit
  val clearCaches : ctx -> unit
end
.Ed
.
.Ss Description
.Bl -tag -width indent
.It Li new
Create a context from a configuration.  May be quite slow - don't call
it too often.  May throw
.Li Error
if initialisation of the Futhark context fails, or if an invalid
tuning parameter is provided in the configuration.
.It Li free
Free a context.  It may not be used again.  There is no guarantee that
this frees any Futhark values (e.g. arrays) associated with the
context.  To avoid memory leaks, make sure to free all values before
freeing the context.
.It Li sync
Wait for all asynchronous operations to finish.  depending on the
Futhark backend, entry points may execute asynchronously, and errors
may not be reported until the next function call.  Use
.Li Context.sync
to ensure all errors have been detected.
.It Li report
Retrieve (and reset) current profiling information. Contains much more
interesting information if the configuration had its
.Li profiling
field set to true.
.It Li pauseProfiling
Temporarily suspend the collection of profiling information. Has no
   effect if profiling was not enabled in the configuration, or if
   profiling is already paused.
.It Li unpauseProfiling
Resume the collection of profiling information. Has no effect if
profiling was not enabled in the configuration, or if profiling is not
currently paused.
.It Li clearCaches
Release any context-internal caches and buffers that may otherwise use
computer resources. Will not invalidate any values or ongoing
computation.
.El
.
.Sh The Entry Structure
.
This structure contains an SML function for each corresponding Futhark
entry point.  They all have the type
.Bd -literal -offset indent
val foo : ctx -> args -> result
.Ed
.Pp
where
.Li args
and
.Li result
may be tuples.
.
Futhark's scalar types are mapped directly to the corresponding SML
types, e.g.
.Li f64
to
.Li Real64 .
.
Each non-primitive type is represented by an appropriate abstract
type, which presents an interface to the underlying Futhark value, as
discussed below.  While execution of an entry point can in principle
be asynchronous, this is not semantically visible.  The result(s)
returned by an entry point can be used immediately.  You only need to call
.Li Context.sync
if you wish to check for errors.
.
.Sh Array Structures
.
Depending on the target compiler, each Futhark array type is
represented by a structure implementing one of the the signatures
below.  The
.Ar mlton-poly
target uses polymorphic arrays, while all other targets use
monomorphic arrays.
.
.Bd -literal -offset indent
signature FUTHARK_MONO_ARRAY =
sig
  type array
  type ctx
  type shape
  structure Array : MONO_ARRAY
  structure Slice : MONO_ARRAY_SLICE
  val new: ctx -> Slice.slice -> shape -> array
  val free: array -> unit
  val shape: array -> shape
  val values: array -> native.array
  val values_into: array -> Slice.slice -> unit
end

signature FUTHARK_POLY_ARRAY =
sig
  type array
  type ctx
  type shape
  type elem
  val new: ctx -> elem ArraySlice.slice -> shape -> array
  val free: array -> unit
  val shape: array -> shape
  val values: array -> elem Array.array
  val values_into: array -> elem ArraySlice.slice -> unit
end
.Ed
.Pp
The name of an array structure is similar to the naming of monomorphic
arrays in the SML basis library, e.g.,
.Li Int32Array1
for
.Li []i32
and
.Li Real32Array32
for
.Li [][]f32 .
.
.Ss Description
.
.Bl -tag -width indent
.It Li array
The abstract array type.
.It Li ctx
The Futhark context type.  Each array structure refines this to be identical to the
.Li ctx
type of the top level structure.
.It Li shape
A type for the shape of the array. This is
.Li int
for single dimensional arrays, and otherwise a tuple of integers.
.It Li new
Construct a Futhark array from an SML array slice.  Raises
.Li Size
if the length of the array slice is not equal to the product of the
provided shape.
.It Li free
Frees the array. Do not use it again. If you do not manually call this
function when you are done with the array, then you leak memory.
.It Li values
Synchronously copy the Futhark array into a freshly constructed SML array.
.It Li values_into
Synchronously copy the Futhark array into an existing SML array slice.  Raises
.Li Size
if the length of the slice is not equal to the product of the array
shape.
.El
.
.Sh Opaque types
.
Each non-record opaque type is represented by a structure implementing
the signature below.
.Bd -literal -offset indent
signature FUTHARK_OPAQUE =
sig
  type t
  type ctx
  val free    : t -> unit
  val store   : t -> Word8Array.array
  val restore : ctx -> Word8ArraySlice.slice -> t
end
.Ed
.Ss Description
.
.Bl -tag -width indent
.It Li free
Frees the object. Do not use it again. If you do not manually call this
function when you are done with the object, then memory will be leaked.
.It Li store
Serialise the value to a byte array.
.It Li restore
Restore a value from its serialised representation. Note that you
should not pass untrusted data to this function, as this can result in
memory corruption.
.El
.
.Pp
The serialisation format is stable across compiler backends and
recompilation, but not necessarily across different compiler versions,
although in practice compatibility is broken very rarely.
.
.Sh Record types
.
Each record type is represented by a structure implementing the
signature below.
.Bd -literal -offset indent
signature FUTHARK_RECORD =
sig
  include FUTHARK_OPAQUE
  type record
  val values : t -> record
  val new : ctx -> record -> t
end
.Ed
.Pp
Any struct that implements this signature will refine the
.Li record
type such that the Futhark value can be constructed from an
appropriate SML record.
.
Note that if you convert a Futhark record into an SML record with
.Li values ,
you must still also free the original Futhark record at some point.
.
.Sh Sum types
.
Each sum type is represented by a structure implementing the signature
below.
.Bd -literal -offset indent
signature FUTHARK_SUM =
sig
  include FUTHARK_OPAQUE
  type sum
  val values: t -> sum
  val new: ctx -> sum -> t
end
.Ed
.Pp
Any struct that implements this signature will define the type
.Li sum
to be an SML mirror of the Futhark-level sum type.
.
Note that if you convert a Futhark sum type value into an SML value
with
.Li values ,
you must still also free the original Futhark object at some point.
.
.Sh Entry points
.
Each Futhark entry point becomes a function with two parameters: the
context object, and a tuple with one element per parameter of the
original Futhark function.
.
.Sh Linking Futhark with MLton
.
The Futhark compiler produces C code, which must be passed to
.Xr mlton 1
in order to produce an executable.  This can be done simply by passing
the .c file to
.Xr mlton 1
on the command line, along with the .sml and/or .mlb file.  However,
if you want to use a GPU backend, you must also pass the appropriate
linker flags, e.g.
.Bd -literal -offset indent
mlton foo.mlb foo.c foo.smlfut.c -link-opt '-lcuda -lnvrtc -lcudart'
.Ed
.Pp
for CUDA.  Note that
.Li foo.c
is the file produced by
.Xr futhark 1 ,
while
.Li foo.smlfut.c
is the file generated by
.Nm .
See the Futhark documentation for the appropriate linker flags needed
for a given backend.
.Sh Linking Futhark with MLKit
.
The same general concerns apply with MLKit as with MLton. To link with
MLKit, you must compile the C file generated by the Futhark compiler,
.Li foo.c ,
and the C file produced by
.Nm
.Li foo.smlfut.c ,
to object files
.Li foo.o
and
.Li foo.smlfut.o ,
and then combine them to a single archive file with
.Bd -literal -offset indent
ar r libfoo.a test.o test.smlfut.o
.Ed
.Pp
The
.Li libfoo.a
file can then be supplied to MLKit by passing
.Bd -literal -offset indent
-libs m,c,dl,test
.Ed
.Pp
on the command line (along with other relevant linker flags).
.
.Sh Bugs
The generated code currently supports only MLton, MPL, and MLKit.
.Pp
The generated code directly exposes the manual memory management
required by Futhark's C interface.  If you neglect to free the values
built using constructor functions or entry points, you will leak
memory.  Freeing the context before freeing all associated values will
also leak memory.
.Pp
Be careful not to mix values associated with different contexts.  They
have the same type, so this is an easy mistake to make.
.
.Sh License
.Nm
itself is released under the GPLv3 or later.  The code
.Em generated
by
.Nm
may be used for any purpose, without restrictions or requirements,
without any need for attribution.
