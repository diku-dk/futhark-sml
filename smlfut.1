.Dd 2023
.Dt 1
.Sh Name
.Nm smlfut
.Nd call Futhark from Standard ML.
.
.Sh Synopsis
.Nm
.SY smlfut
.Op Ar options
.Bk
.Ar MANIFEST.json
.Ek
.
.Sh Description
.Nm
allows SML programs to invoke Futhark programs via Futhark's C API, by
generating appropriate wrapper code, which is then compiled as normal
with an SML compiler.
.
.Sh Options
.
.Bl -tag
.
.It Fl -mono-arrays
Use monomorphic arrays in signature.
.
.It Fl -poly-arrays
Use polymorphic arrays in signature.  This is the default.
.
.It Fl -output-directory Ns = Ns Ar NAME
Write output files to this directory.
.
.It Fl -signature-name Ns = Ns Ar NAME
Use this name for the SML signature.  Defaults to the uppercased
basename of the manifest file.
.
.It Fl -structure-name Ns = Ns Ar NAME
Use this name for the SML structure.  Defaults to the basename of the
manifest file.
.El
.
.Sh Usage
.Pp
First compile a Futhark program
.Li foo.fut
with
.Xr futhark 1
using one of the C backends, then pass the generated JSON manifest
file
.Li foo.json
to
.Nm .
.
This will produce three files:
.Li foo.sig Ns ,
.Li foo.sml Ns ,
and
.Li foo.smlfut.c Ns .

The first two files contain definitions of SML signatures and
structures, while the last contains C code.  The name of the structure
will be taken from the file basename (in this case 'foo') and the
signature name will be the structure name in all caps ('FOO').  The
generated SML files can be passed to the SML compiler, and the final
executable must be linked with
.Li foo.smlfut.c Ns
.Ns ,
and of course the C file generated by the Futhark compiler itself.
.Pp
The generated interface directly exposes the C API, so it is low
level.  The only concession is that the C error codes are turned into
SML exceptions.
.Pp
The generated signatures are designed to be human readable and should
be mostly straightforward.  The general principle is that you construct a
.I "context"
by passing a configuration record.  The context maintains Futhark
state and is passed to entry points and various other functions.
Different context objects are not interchangeable, despite having the
same type, and Futhark values obtained via one context may not be
passed to another.
.Pp
..
.Sh Generated Interface
.
The generated structure implements the following signature (here using
the name
.Li FUTHARK ,
but this is taken from the program file name or the
.Fl -signature-name
option).
.Bd -literal -offset indent
signature FUTHARK =
sig
  val backend : string
  val version : string

  type ctx
  exception error of string
  type cfg = {logging:bool, debugging:bool, profiling:bool, cache:string option}
  val default_cfg : cfg
  val ctx_new : cfg -> ctx
  val ctx_free : ctx -> unit
  val ctx_sync : ctx -> unit

  (* Array specs... *)

  structure Opaque : sig
    (* Opaque type specs... *)
  end

  structure Entry : sig
    (* Entry points... *)
  end
end
.Ed
.Pp
The
.Li backend
and
.Li version
definitions denote which Futhark backend and compiler version was used
to compile the program.
.
All errors are reported by raising an
.Li error
exception.  Note that depending on the Futhark backend, entry points
may execute asynchronously, and errors may not be reported until the
next function call.  Use
.Li ctx_sync
to ensure all errors have been detected.
.
Futhark's scalar types are mapped directly to the corresponding SML
types, e.g.
.Li f64
to
.Li Real64 .
.
Each non-primitive type is represented by an appropriate structure,
which presents an abstract interface to the underlying Futhark value,
as discussed below.
.
.Ss Array types
.
When using
.Fl -mono-arrays Ns
, each array type is represented by a structure implementing the
signature below.
.
.Bd -literal -offset indent
signature FUTHARK_MONO_ARRAY =
sig
  type array
  type ctx
  type shape
  structure Array : MONO_ARRAY
  structure Slice : MONO_ARRAY_SLICE
  val new: ctx -> native.array -> shape -> array
  val free: array -> unit
  val shape: array -> shape
  val values: array -> native.array
  val values_into: array -> Slice.slice -> unit
end
.Ed
.Pp
When using
.Fl -poly-arrays Ns
(the default), arrays are represented by the following signature.
.Bd -literal -offset indent
signature FUTHARK_POLY_ARRAY =
sig
  type array
  type ctx
  type shape
  type elem
  val new: ctx -> elem Array.array -> shape -> array
  val free: array -> unit
  val shape: array -> shape
  val values: array -> elem Array.array
  val values_into: array -> elem ArraySlice.slice -> unit
end
.Ed

.Pp
Futhark arrays can be converted to and from the corresponding SML
arrays.  The
.Li values
function allocates a fresh array, while
.Li values_into
copies into an existing array slice.  The
.Li Array
and
.Li Slice
structures references exactly the corresponding monomorphic array and
array slice structures from the SML Basis library.
.
In contrast to the raw C API, the
.Li new
and
.Li values
/
.Li values_into
functions are synchronous, and do not need explicit synchronisation.
.
.Ss Opaque types
.
Each non-record opaque type is represented by a structure implementing
the signature below.
.Bd -literal -offset indent
signature FUTHARK_OPAQUE =
sig
  type t
  type ctx
  val free : t -> unit
end
.Ed
.Ss Record types
.
Each record type is represented by a structure implementing the
signature below.
.Bd -literal -offset indent
signature FUTHARK_RECORD =
sig
  include FUTHARK_OPAQUE
  type record
  val values : t -> record
  val new : ctx -> record -> t
end
.Ed
.Pp
Any struct that implements this signature will refine the record type
such that the Futhark value can be constructed from an appropriate SML
record.
.
Note that if you convert a Futhark record into an SML record with
.Li values ,
you must still also free the original Futhark record at some point.
.
.Ss Entry points
.
Each Futhark entry point becomes a function with two parameters: the
context object, and a tuple with one element per parameter of the
original Futhark function.
.
.Sh Linking Futhark with MLton
.
The Futhark compiler produces C code, which must be passed to
.Xr mlton 1
in order to produce an executable.  This can be done simply by passing
the .c file to
.Xr mlton 1
on the command line, along with the .sml and/or .mlb file.  However,
if you want to use a GPU backend, you must also pass the appropriate
linker flags, e.g.
.Bd -literal -offset indent
mlton foo.mlb foo.c foo.smlfut.c -link-opt '-lcuda -lnvrtc -lcudart'
.Ed
.Pp
for CUDA.  Note that
.Li foo.c
is the file produced by
.Xr futhark 1 ,
while
.Li foo.smlfut.c
is the file generated by
.Nm .
See the Futhark documentation for the appropriate linker flags needed
for a given backend.
.Sh Bugs
The generated code currently supports only MLton (and perhaps MPL).
.Pp
The generated code directly exposes the manual memory management
required by Futhark's C interface.  If you neglect to free the values
built using constructor functions or entry points, you will leak
memory.  Freeing the context before freeing all associated values will
also leak memory.
.Pp
Be careful not to mix values associated with different contexts.  They
have the same type, so this is an easy mistake to make.
.
.Sh License
.Nm
itself is released under the GPLv3 or later.  The code
.Em generated
by
.Nm
may be used for any purpose, without restrictions or requirements,
without any need for attribution.
