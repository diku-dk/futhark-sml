.Dd 2023
.Dt 1
.Sh Name
.Nm smlfut
.Nd call Futhark from Standard ML.
.
.Sh Synopsis
.Nm
.SY smlfut
.Bk
.Ar manifest
.Ek
.
.Sh Description
.Nm
allows SML programs to invoke Futhark programs via Futhark's C API, by
generating appropriate wrapper code, which is then compiled as normal
with an SML compiler.
.
.Sh Usage
.Pp
First compile a Futhark program
.I foo.fut
with
.Xr futhark 1
using one of the C backends, then pass the generated JSON manifest
file
.I foo.json
to
.Nm .
.
This will produce two files
.I foo.sig
and
.IR foo.sml ,
containing a signatures and structure definitions respectively.  The
name of the structure will be taken from the file basename (in this
case
.IR foo ),
and the signature name will be the structure name in
uppercase
.RI ( FOO ).
.
The generated files must then be compiled with a SML compiler.
.
The generated interface directly exposes the C API, so it is low
level.  The only concession is that the C error codes are turned into
SML exceptions.
.Pp
The generated signatures are designed to be human readable and should
be mostly straightforward.  The general principle is that you construct a
.I "context"
by passing a configuration record.  The context maintains Futhark
state and is passed to entry points and various other functions.
Different context objects are not interchangeable, despite having the
same type, and Futhark values obtained via one context may not be
passed to another.
.Pp
Futhark's scalar types are mapped directly to the corresponding SML types, e.g.
.Em f64
to
.Em Real64.
Arrays and opaque types are mapped to abstract SML types, each
contained in a structure that defines functions for interacting with
them.
.
.Pp
In contrast to the C API, the functions for copying data to and from
Futhark are synchronous, and do not need explicit synchronisation.
However, entry points are still asynchronous, meaning that errors can
be delayed until a future operation.  Use the 'sync' function if you
want to ensure all errors have been checked.
.
.Ss Linking Futhark with MLton
.
The Futhark compiler produces C code, which must be passed to
.Xr mlton 1
in order to produce an executable.  This can be done simply by passing
the .c file to
.Xr mlton 1
on the command line, along with the .sml and/or .mlb file.  However,
if you want to use a GPU backend, you must also pass the appropriate
linker flags, e.g.
.Pp
.Li mlton foo.mlb foo.c -link-opt '-lcuda -lnvrtc -lcudart'
.Pp
for CUDA.  See the Futhark documentation for the appropriate linker
flags needed for a given backend.
.Sh Bugs
The generated code currently supports only MLton (and perhaps MPL).
.Pp
The generated code directly exposes the manual memory management
required by Futhark's C interface.  If you neglect to free the values
built using constructor functions or entry points, you will leak
memory.  Freeing the context before freeing all associated values will
also leak memory.
.Pp
Be careful not to mix values associated with different contexts.  They
have the same type, so this is an easy mistake to make.
.Pp
If the manifest file name, entry points, or names of exposed types are
not valid SML identifiers, the generated code will contain syntax
errors.
.
.Sh License
.Nm
itself is released under the GPLv3 or later.  The code
.I generated
by
.Nm
may be used for any purpose, without restrictions or requirements,
without any need for attribution.
